#!/usr/bin/env python3
"""
claude-pace - Claude usage tracker with pace calculation
Outputs JSON for ccstatusline integration

Features:
- Fetches usage from Anthropic OAuth API
- Calculates pace_ratio (current rate vs sustainable rate)
- Caches results to avoid excessive API calls

Usage: claude-pace [OPTIONS]
  --force          Bypass cache and fetch fresh data
  --pretty         Human-readable formatted output
  --watch, -w      Interactive mode: auto-reload every 20min, press 'r' to refresh
  --always-on-7d   Compact statusline segment for weekly window
  --always-on-5h   Compact statusline segment for 5h window
  --no-dots        Hide status dots (●●)
  --units          Show days/hours instead of percentages
  --remaining      Show remaining instead of used
  --pace           Show pace ratio (e.g. w:1.05x) instead of values
"""

import json
import math
import os
import select
import subprocess
import sys
import termios
import tty
import urllib.request
from datetime import datetime, timezone
from pathlib import Path

CACHE_DIR = Path(os.environ.get("XDG_CACHE_HOME", Path.home() / ".cache")) / "claude-pace"
CACHE_FILE = CACHE_DIR / "usage.json"
CONFIG_FILE = Path.home() / ".config" / "claude-pace" / "config.json"
LOCK_FILE = CACHE_DIR / "refresh.lock"
CACHE_TTL = 300  # 5 minutes

# Default working hours config (can be overridden in config.json)
DEFAULT_CONFIG = {
    "work_start": "08:00",  # Start of work day
    "work_end": "02:00",    # End of work day (next day if < start)
    "working_hours_per_day": 18,  # Fallback if start/end not set
}


def load_config() -> dict:
    """Load config from file or return defaults."""
    if CONFIG_FILE.exists():
        try:
            user_config = json.loads(CONFIG_FILE.read_text())
            return {**DEFAULT_CONFIG, **user_config}
        except (json.JSONDecodeError, OSError):
            pass
    return DEFAULT_CONFIG


def calc_working_hours_per_day(config: dict) -> float:
    """Calculate working hours per day from start/end times."""
    start = config.get("work_start", "08:00")
    end = config.get("work_end", "02:00")

    start_h, start_m = map(int, start.split(":"))
    end_h, end_m = map(int, end.split(":"))

    start_mins = start_h * 60 + start_m
    end_mins = end_h * 60 + end_m

    # Handle overnight (e.g., 08:00 - 02:00)
    if end_mins <= start_mins:
        end_mins += 24 * 60

    return (end_mins - start_mins) / 60


def get_cache_age() -> float:
    """Return cache age in seconds, or inf if no cache."""
    if not CACHE_FILE.exists():
        return float("inf")
    return (datetime.now().timestamp() - CACHE_FILE.stat().st_mtime)


def read_cache() -> dict | None:
    """Read cached data if valid."""
    if get_cache_age() < CACHE_TTL:
        return json.loads(CACHE_FILE.read_text())
    return None


def read_cache_any() -> dict | None:
    """Read cached data regardless of age."""
    if CACHE_FILE.exists():
        return json.loads(CACHE_FILE.read_text())
    return None


def write_cache(data: dict) -> None:
    """Write data to cache."""
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    CACHE_FILE.write_text(json.dumps(data))


def spawn_background_refresh() -> None:
    """Spawn a detached background process to refresh the cache.

    Uses a lock file to prevent concurrent refreshes.
    """
    # Check lock: skip if another refresh is already running
    if LOCK_FILE.exists():
        lock_age = datetime.now().timestamp() - LOCK_FILE.stat().st_mtime
        if lock_age < 30:  # stale lock after 30s
            return
    subprocess.Popen(
        [sys.executable, __file__, "--force", "--bg-refresh"],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
        start_new_session=True,
    )


def get_token() -> str:
    """Get OAuth token from macOS Keychain."""
    result = subprocess.run(
        ["security", "find-generic-password", "-s", "Claude Code-credentials", "-w"],
        capture_output=True,
        text=True,
        check=True,
    )
    creds = json.loads(result.stdout.strip())
    return creds["claudeAiOauth"]["accessToken"]


def fetch_usage(token: str) -> dict:
    """Fetch usage data from Anthropic API."""
    req = urllib.request.Request(
        "https://api.anthropic.com/api/oauth/usage",
        headers={
            "Authorization": f"Bearer {token}",
            "anthropic-beta": "oauth-2025-04-20",
        },
    )
    with urllib.request.urlopen(req, timeout=10) as resp:
        return json.loads(resp.read().decode())


def parse_reset(reset_str) -> datetime:
    """Parse ISO timestamp to datetime. Returns epoch on bad input."""
    if not isinstance(reset_str, str):
        return datetime(1970, 1, 1, tzinfo=timezone.utc)
    try:
        return datetime.fromisoformat(reset_str)
    except (ValueError, TypeError):
        return datetime(1970, 1, 1, tzinfo=timezone.utc)


# Base status thresholds (adjusted dynamically based on utilization)
PACE_WARNING = 1.0       # Warning if pace > 1.0 (using quota faster than sustainable)
PACE_CRITICAL = 1.3      # Critical if pace > 1.3 (aligned with README)

# Minimum utilization before pace-based warnings apply
# Below this threshold, there's plenty of runway to recover
MIN_UTIL_FOR_PACE_WARNING = 10  # Don't warn based on pace alone if < 10% used


def calc_runway(utilization: float, daily_avg: float, hours_remaining: float, working_hours_per_day: float = 18) -> dict:
    """Calculate runway metrics (how long until quota exhaustion).

    Runway is the number of WORKING hours remaining at current burn rate.
    Safety ratio compares runway to working time remaining until reset.

    Args:
        utilization: Current usage percentage
        daily_avg: Average daily usage rate (percentage per day)
        hours_remaining: Total hours until reset (calendar time)
        working_hours_per_day: Hours per day actually spent working (default 18)
    """
    remaining_pct = 100 - utilization

    # Convert to working hours
    days_remaining = hours_remaining / 24
    working_hours_remaining = days_remaining * working_hours_per_day

    # Burn rate per working hour (not calendar hour)
    burn_rate_working_hour = daily_avg / working_hours_per_day if daily_avg > 0 else 0

    if burn_rate_working_hour > 0:
        runway_hours = remaining_pct / burn_rate_working_hour
    else:
        runway_hours = float('inf')

    if working_hours_remaining > 0:
        safety_ratio = runway_hours / working_hours_remaining
    else:
        safety_ratio = 0 if utilization >= 100 else float('inf')

    return {
        "runway_hours": round(runway_hours, 1) if runway_hours != float('inf') else 9999,
        "hours_remaining": round(working_hours_remaining, 1),  # Now in working hours
        "calendar_hours_remaining": round(hours_remaining, 1),
        "safety_ratio": round(safety_ratio, 2) if safety_ratio != float('inf') else 99,
        "buffer_hours": round(runway_hours - working_hours_remaining, 1) if runway_hours != float('inf') else 9999,
        "working_hours_per_day": working_hours_per_day,
    }


def elapsed_tolerance(elapsed_fraction: float) -> float:
    """Scale factor for alert thresholds based on how far into the window we are.

    Early in the window, linear extrapolation from a tiny sample is unreliable.
    This returns a multiplier > 1.0 that makes thresholds harder to breach early,
    converging to 1.0 (no adjustment) as the window progresses.

    Based on the inverse-sqrt curve used in confidence-interval scaling and
    SRE burn-rate alerting: uncertainty decreases as 1/sqrt(observations).

    Reference values (7-day window):
        t=0.01 (~1.7h)  -> 3.7x  (very forgiving)
        t=0.05 (~8.4h)  -> 2.0x
        t=0.14 (~1 day) -> 1.5x
        t=0.25 (~1.75d) -> 1.3x
        t=0.50 (~3.5d)  -> 1.1x
        t=1.00 (7d)     -> 1.0x  (base thresholds)
    """
    t = max(elapsed_fraction, 0.01)
    return 1.0 + 0.3 * max(0.0, (1.0 / math.sqrt(t)) - 1.0)


def calc_status(pace_ratio: float, safety_ratio: float, utilization: float, elapsed_fraction: float = 1.0) -> str:
    """Determine status from combined pace and safety metrics.

    Thresholds adapt on two axes:
    1. Utilization — how much budget is consumed (low=lenient, high=strict)
    2. Elapsed fraction — how far through the time window (early=lenient, late=strict)

    The elapsed-fraction scaling prevents false CRITICALs from early bursts where
    linear extrapolation is dominated by noise. As the window progresses, thresholds
    converge to their base values.
    """
    pace_matters = utilization >= MIN_UTIL_FOR_PACE_WARNING

    # Base safety thresholds (utilization-dependent)
    if utilization > 50:
        safety_critical = 0.85
        safety_warning = 1.15
    elif utilization > MIN_UTIL_FOR_PACE_WARNING:
        safety_critical = 0.7
        safety_warning = 1.0
    else:
        safety_critical = 0.5
        safety_warning = 0.7

    # Apply elapsed-fraction scaling: divide safety thresholds (harder to breach
    # early), multiply pace thresholds (harder to breach early)
    tol = elapsed_tolerance(elapsed_fraction)
    eff_safety_critical = safety_critical / tol
    eff_safety_warning = safety_warning / tol
    eff_pace_critical = PACE_CRITICAL * tol
    eff_pace_warning = PACE_WARNING * tol

    # Critical: exhaustion projected OR extreme pace (if enough data)
    if safety_ratio < eff_safety_critical:
        return "critical"
    if pace_matters and pace_ratio > eff_pace_critical:
        return "critical"

    # Warning: reduced margin OR elevated pace
    if safety_ratio < eff_safety_warning:
        return "over_pace"
    if pace_matters and pace_ratio > eff_pace_warning:
        return "over_pace"

    # Extreme pace at low utilization: warn (never critical) so the user
    # still knows they're burning fast. Cap at 1.2x keeps the threshold
    # reachable (1.3 * 1.2 = 1.56x) even when time tolerance is very high.
    if not pace_matters and pace_ratio > PACE_CRITICAL * min(tol, 1.2):
        return "over_pace"

    if pace_ratio <= 0.8:
        return "under_pace"

    return "on_track"


def calc_pace(utilization: float, resets_at: str, window_days: int, config: dict | None = None) -> dict:
    """Calculate pace ratio: current daily rate vs sustainable rate."""
    if config is None:
        config = load_config()

    working_hours_per_day = calc_working_hours_per_day(config)

    now = datetime.now(timezone.utc)
    reset_dt = parse_reset(resets_at)
    days_remaining = (reset_dt - now).total_seconds() / 86400
    days_elapsed = window_days - days_remaining

    if days_elapsed <= 0:
        days_elapsed = 0.1

    daily_avg = utilization / days_elapsed
    sustainable_rate = 100.0 / window_days
    pace_ratio = daily_avg / sustainable_rate

    # Calculate runway and safety metrics (using working hours)
    hours_remaining = days_remaining * 24
    runway = calc_runway(utilization, daily_avg, hours_remaining, working_hours_per_day)

    # Determine status from combined metrics (with dynamic thresholds)
    elapsed_fraction = days_elapsed / window_days
    status = calc_status(pace_ratio, runway["safety_ratio"], utilization, elapsed_fraction)

    return {
        "pct": utilization,
        "days_elapsed": round(days_elapsed, 1),
        "days_remaining": round(days_remaining, 1),
        "daily_avg": round(daily_avg, 1),
        "sustainable_rate": round(sustainable_rate, 1),
        "pace_ratio": round(pace_ratio, 2),
        "projected_eow": round(daily_avg * window_days, 1),
        "resets_at": resets_at,
        "status": status,
        "runway_hours": runway["runway_hours"],
        "working_hours_remaining": runway["hours_remaining"],
        "safety_ratio": runway["safety_ratio"],
        "buffer_hours": runway["buffer_hours"],
        "working_hours_per_day": working_hours_per_day,
    }


def format_duration(seconds: float) -> str:
    """Format seconds as human readable duration."""
    if seconds < 0:
        return "now"
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    if hours > 24:
        days = hours // 24
        hours = hours % 24
        return f"{days}d {hours}h"
    return f"{hours}h {minutes}m"


def process_usage(data: dict) -> dict:
    """Process raw usage data into pace metrics."""
    now = datetime.now(timezone.utc)

    five_hour = data.get("five_hour") or {}
    five_hour_reset = parse_reset(five_hour.get("resets_at"))
    five_hour_remaining = max(0, (five_hour_reset - now).total_seconds())

    # Calculate 5h burn rate
    hours_remaining_5h = five_hour_remaining / 3600
    hours_elapsed_5h = 5 - hours_remaining_5h
    if hours_elapsed_5h <= 0:
        hours_elapsed_5h = 0.1
    pct_5h = five_hour.get("utilization", 0)
    burn_rate = pct_5h / hours_elapsed_5h
    pace_ratio_5h = burn_rate / 20.0  # sustainable = 20%/h

    # 5h status (mirrors widget logic)
    if hours_remaining_5h < 1:
        status_5h = "on_track"  # reset imminent
    elif burn_rate <= 20:
        status_5h = "on_track"
    elif burn_rate <= 25:
        status_5h = "over_pace"
    elif pct_5h > 50:
        status_5h = "critical"
    else:
        status_5h = "over_pace"  # early burst

    seven_day = data.get("seven_day") or {}
    seven_day_pace = calc_pace(
        seven_day.get("utilization", 0),
        seven_day.get("resets_at", ""),
        7,
    )

    return {
        "five_hour": {
            "pct": pct_5h,
            "resets_in": format_duration(five_hour_remaining),
            "resets_at": five_hour["resets_at"],
            "burn_rate": round(burn_rate, 1),
            "pace_ratio": round(pace_ratio_5h, 2),
            "hours_elapsed": round(hours_elapsed_5h, 2),
            "hours_remaining": round(hours_remaining_5h, 2),
            "status": status_5h,
        },
        "seven_day": seven_day_pace,
        "fetched_at": now.isoformat(),
    }


def pace_symbol(ratio: float) -> str:
    """Return symbol representing pace ratio: ≪ < ≈ > ≫."""
    if ratio > 1.2:
        return "≫"
    if ratio >= 0.9:
        return ">"
    if ratio >= 0.8:
        return "≈"
    if ratio >= 0.5:
        return "<"
    return "≪"


def ansi_wrap(text: str, status: str) -> str:
    """Wrap text in ANSI color based on status. No-op for green statuses."""
    yellow = "\033[38;2;255;200;50m"
    red = "\033[38;2;255;85;85m"
    reset = "\033[0m"
    if status == "critical":
        return f"{red}{text}{reset}"
    if status == "over_pace":
        return f"{yellow}{text}{reset}"
    return text


def dot_color(status: str) -> str:
    """Return colored ● for status: dim_green / yellow / red."""
    dim_green = "\033[38;2;100;200;100m"
    yellow = "\033[38;2;255;200;50m"
    red = "\033[38;2;255;85;85m"
    reset = "\033[0m"
    if status == "critical":
        return f"{red}●{reset}"
    if status == "over_pace":
        return f"{yellow}●{reset}"
    return f"{dim_green}●{reset}"


def format_compact_segment(
    prefix: str,
    pct: float,
    pace_ratio_val: float,
    elapsed: float,
    window_size: float,
    status: str,
    units: bool,
    remaining: bool,
    pace: bool,
) -> str:
    """Render one compact segment like w:60>57 or h:2.5≈1.3."""
    if pace:
        text = f"{prefix}:{pace_ratio_val:.2f}x"
        return ansi_wrap(text, status)

    sym = pace_symbol(pace_ratio_val)

    if units:
        if remaining:
            left = window_size - elapsed
            right = (window_size * (100 - pct)) / 100
        else:
            left = elapsed
            right = (window_size * pct) / 100
        text = f"{prefix}:{left:.1f}{sym}{right:.1f}"
    else:
        if remaining:
            left_val = min(99, int(100 - pct))
            right_val = min(99, int((1 - elapsed / window_size) * 100))
        else:
            left_val = min(99, int(pct))
            right_val = min(99, int(elapsed / window_size * 100))
        text = f"{prefix}:{left_val:02d}{sym}{right_val:02d}"

    return ansi_wrap(text, status)


def print_always_on(
    data: dict,
    show_7d: bool,
    show_5h: bool,
    dots: bool,
    units: bool,
    remaining: bool,
    pace: bool,
) -> None:
    """Print compact statusline with composable flags."""
    parts: list[str] = []
    weekly = data.get("seven_day", {})
    five_h = data.get("five_hour", {})

    w_status = weekly.get("status", "on_track")
    h_status = five_h.get("status", "on_track")

    if dots:
        parts.append(dot_color(w_status) + dot_color(h_status))

    if show_7d:
        parts.append(format_compact_segment(
            prefix="w",
            pct=weekly.get("pct", 0),
            pace_ratio_val=weekly.get("pace_ratio", 0),
            elapsed=weekly.get("days_elapsed", 0),
            window_size=7,
            status=w_status,
            units=units,
            remaining=remaining,
            pace=pace,
        ))

    if show_5h:
        parts.append(format_compact_segment(
            prefix="h",
            pct=five_h.get("pct", 0),
            pace_ratio_val=five_h.get("pace_ratio", 0),
            elapsed=five_h.get("hours_elapsed", 0),
            window_size=5,
            status=h_status,
            units=units,
            remaining=remaining,
            pace=pace,
        ))

    print(" ".join(parts), end="")


def pretty_print(data: dict) -> None:
    """Print human-readable formatted output."""
    # Colors
    dim = "\033[90m"
    green = "\033[38;2;100;200;100m"
    yellow = "\033[38;2;255;200;50m"
    red = "\033[38;2;255;85;85m"
    bold = "\033[1m"
    reset = "\033[0m"

    weekly = data.get("seven_day", {})
    five_h = data.get("five_hour", {})

    # Determine weekly color based on status
    status = weekly.get("status", "on_track")
    if status == "critical":
        w_col = red
        w_status = "CRITICAL"
    elif status == "over_pace":
        w_col = yellow
        w_status = "warning"
    elif status == "under_pace":
        w_col = green
        w_status = "banking"
    else:
        w_col = green
        w_status = "on track"

    # Determine 5h color (sustainable rate = 20%/h)
    burn = five_h.get("burn_rate", 0)
    if burn <= 20:
        h_col = green
    elif burn <= 25:
        h_col = yellow
    else:
        h_col = red

    print(f"\n{bold}Claude Usage{reset}\n")

    # Weekly section
    w_pct = weekly.get("pct", 0)
    w_remaining = 100 - w_pct
    w_proj = weekly.get("projected_eow", 0)
    w_days = weekly.get("days_remaining", 0)
    pace = weekly.get("pace_ratio", 0)
    safety = weekly.get("safety_ratio", 99)
    runway = weekly.get("runway_hours", 9999)
    buffer = weekly.get("buffer_hours", 9999)

    working_h_remaining = weekly.get("working_hours_remaining", w_days * 18)
    working_h_per_day = weekly.get("working_hours_per_day", 18)

    print(f"{bold}Weekly (7 days){reset}")
    print(f"  Used: {w_col}{w_pct:.0f}%{reset} │ Remaining: {w_remaining:.0f}%")
    print(f"  Pace: {w_col}{pace:.2f}x{reset} ({w_status})")
    print(f"  Safety: {w_col}{safety:.2f}x{reset} │ Runway: {runway:.0f}h │ Buffer: {buffer:+.0f}h")
    print(f"  Projected EOW: {w_col}{w_proj:.0f}%{reset}")
    print(f"  Resets in: {w_days:.1f} days ({working_h_remaining:.0f} working hours)")
    print(f"  {dim}(Working day: {working_h_per_day:.0f}h){reset}")

    print()

    # 5-hour section
    h_pct = five_h.get("pct", 0)
    h_remaining_pct = 100 - h_pct
    h_resets = five_h.get("resets_in", "?")
    h_hours_left = five_h.get("hours_remaining", 0)

    # Safe rate: max burn rate to stay within 100% by reset
    if h_hours_left > 0:
        safe_rate = h_remaining_pct / h_hours_left
    else:
        safe_rate = 0

    print(f"{bold}5-Hour Window{reset}")
    print(f"  Used: {h_col}{h_pct:.0f}%{reset} │ Remaining: {h_remaining_pct:.0f}%")
    print(f"  Burn rate: {h_col}{burn:.1f}%/h{reset} │ Safe rate: {safe_rate:.1f}%/h")
    print(f"  Resets in: {h_resets}")

    print()


def fetch_and_cache() -> dict:
    """Fetch fresh data from API and write to cache. Falls back to stale cache on error."""
    try:
        token = get_token()
        raw_usage = fetch_usage(token)
        result = process_usage(raw_usage)
        write_cache(result)
        return result
    except Exception as exc:
        stale = read_cache_any()
        if stale is not None:
            stale["_stale"] = True
            stale["_error"] = str(exc)
            return stale
        raise


def watch_mode() -> None:
    """Interactive watch mode: auto-reload every 20min, 'r' to refresh, 'q' to quit."""
    RELOAD_INTERVAL = 20 * 60  # 20 minutes in seconds

    def clear_screen():
        print("\033[2J\033[H", end="")

    def print_status(data: dict, last_refresh: datetime):
        clear_screen()
        pretty_print(data)
        dim = "\033[90m"
        reset = "\033[0m"
        print(f"{dim}Last refresh: {last_refresh.strftime('%H:%M:%S')}")
        print(f"Press 'r' to reload, 'q' to quit{reset}")

    # Save terminal settings and set raw mode
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)

    try:
        tty.setcbreak(fd)

        # Initial fetch
        data = fetch_and_cache()
        last_refresh = datetime.now()
        print_status(data, last_refresh)

        while True:
            readable, _, _ = select.select([sys.stdin], [], [], RELOAD_INTERVAL)

            if readable:
                key = sys.stdin.read(1).lower()
                if key == "q":
                    break
                elif key == "r":
                    try:
                        data = fetch_and_cache()
                        last_refresh = datetime.now()
                    except Exception:
                        pass
                    print_status(data, last_refresh)
            else:
                try:
                    data = fetch_and_cache()
                    last_refresh = datetime.now()
                except Exception:
                    pass
                print_status(data, last_refresh)

    except KeyboardInterrupt:
        pass
    finally:
        # Restore terminal settings
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        print()  # Clean exit


def main():
    args = sys.argv[1:]
    force = "--force" in args
    pretty = "--pretty" in args
    watch = "--watch" in args or "-w" in args
    show_7d = "--always-on-7d" in args
    show_5h = "--always-on-5h" in args
    no_dots = "--no-dots" in args
    units = "--units" in args
    remaining = "--remaining" in args
    pace = "--pace" in args
    always_on = show_7d or show_5h
    bg_refresh = "--bg-refresh" in args

    # Background refresh mode: fetch, write cache, exit silently
    if bg_refresh:
        CACHE_DIR.mkdir(parents=True, exist_ok=True)
        LOCK_FILE.touch()
        try:
            fetch_and_cache()
        finally:
            LOCK_FILE.unlink(missing_ok=True)
        return

    # Interactive watch mode
    if watch:
        watch_mode()
        return

    # Try fresh cache first
    result = None
    if not force:
        result = read_cache()

    if result is not None:
        # Cache hit — output immediately
        pass
    elif not force and always_on:
        # Stale-while-revalidate: return stale data, refresh in background
        stale = read_cache_any()
        if stale is not None:
            result = stale
            spawn_background_refresh()
        else:
            # No cache at all — must block
            result = fetch_and_cache()
    else:
        # No cache or --force — fetch synchronously
        result = fetch_and_cache()

    # Output
    if always_on:
        print_always_on(result, show_7d, show_5h, dots=not no_dots, units=units, remaining=remaining, pace=pace)
    elif pretty:
        pretty_print(result)
    else:
        print(json.dumps(result))


if __name__ == "__main__":
    main()
